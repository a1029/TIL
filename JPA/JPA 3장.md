# JPA 3장

## 스터디 2주차
- 김한빈, 이정준, 권영기
- 2021-10-08 ~ 2021-10-10
- 교재 : 자바 ORM 표준 JPA 프로그래밍
- 장소: 온라인 ZOOM

## 엔티티 매니저를 스레드 간에 공유하면 안되는 이유

- DB 트랜잭션이랑 연관지을 수 있을 것 같다.
- 하나의 데이터베이스에는 한 순간에는 하나의 트랜잭션만 수행되어야 한다.
- 엔티티 매니저가 스레드간 공유되서 만약 동시에 작업을 하면 데이터 동시성 문제가 발생할 수 있다.
- 운영체제의 세마포어와도 비슷한가?

## 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경
- 엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장

## 엔티티 생명주기

- 비영속, 영속, 준영속, 삭제

## 영속성 컨텍스트 특징

- 영속상태의 엔티티 식별자 : @id로 테이블의 기본키와 매핑한 값
- 1차 캐시 : 영속상태의 엔티티 저장소
- 동일성 보장 : 1차 캐시 덕분
- 쓰기 지연 : 쓰기 지연 SQL 저장소
- 변경 감지 : 스냅샷
- 지연 로딩
- 엔티티 조회
    - `em.find(Entity.class, [entity.key])`
    - 1차 캐시에서 먼저 찾고 없으면 데이터베이스를 조회해서 엔티티 생성, 그리고 1차 캐시에 저장한 후에 엔티티 반환
- 엔티티 등록
    - `em.persist(entity)`
    - 엔티티를 영속화함, 1차 캐시에 저장, 그리고 엔티티를 저장하면서 등록 쿼리를 생성. 등록 쿼리를 쓰기 지연 SQL 저장소에 보관. 실제 데이터베이스에는 반영X
    - 실제 데이터베이스에 반영되는 것은 트랜잭션이 커밋될때임. 트랜잭션이 커밋될때 영속성 컨텍스트 플러시가 되고, 플러시는 쓰기 지연 SQL 저장소에 저장해둔 등록 쿼리를 데이터베이스로 보냄으로써 실제 데이터베이스에 반영됨
    - 커밋될때 실제 데이터베이스에 반영되기 때문에 쓰기 지연이 가능. 커밋하지 않으면 데이터베이스에 절대 반영되지 않음
- 엔티티 수정
    - `em.update(entity)` → 이런 메소드는 존재하지 않음
    - `Entity.setName(newName)` → 이렇게 엔티티의 속성만 바꿔주기만 하면 됨
    - JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장. 이를 스냅샷이라고 함
    - 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾음 변경된 엔티티가 있으면 엔티티 등록과 비슷하게 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보관함. 트랜잭션이 커밋되면 쓰기 지연 SQL에 저장한 수정 쿼리가 실제 데이터베이스로 전송
    - JPA는 수정 작업시 엔티티의 특정 필드가 아닌 항상 모든 필드를 업데이트함.
    - DynamicUpdate
- 엔티티 삭제
    - `em.remove(entity)`
    - 엔티티 등록과 비슷하게 삭제쿼리가 지연 SQL 저장소에 저장, 커밋, 플러시 과정을 거침
    - 엔티티 객체는 영속성 컨텍스트에서 즉시 제거. 그리고 가비지 컬렉션 대상이 됨

## 플러시

- 영속성 컨텍스트의 변경 내용을 실제 데이터베이스에 반영하는 작업
- 플러시 하는 방법 3가지 : 직접 호출, 트랜잭션 커밋 시 플러시 자동 호출, JPQL 쿼리 실행 시 플러시 자동 호출
- 플러시를 한다고 영속성 컨텍스트에 저장된 엔티티를 지우는 것은 아님. 데이터베이스와 동기화를 하는 것

## 준영속

- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태
- 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음
- 준영속으로 만드는 3가지 방법 : `detach(), clear(), close()`
- 준영속 상태의 엔티티를 다시 영속으로 : `merge()` merge는 비영속 상태인 엔티티를 영속상태로 바꿀때, 그 엔티티를 영속으로 바꾸는 것이 아니고 영속 상태인 새로운 엔티티를 반환, 즉 두 인스턴스가 다름
- 비영속 병합?